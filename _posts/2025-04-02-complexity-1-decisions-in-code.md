---
title: Complexity part 1. Specific decisions in code.
date: 2025-04-02
author: topolog
layout: post
permalink: /complexity-1-decisions-in-code
image:
  path: images-posts/2025-04-14-complexity-1-decisions-in-code/header-1500.png
  thumbnail: images-posts/2025-04-14-complexity-1-decisions-in-code/thumb-600.png
  caption: Generated by DALL-E
tags:
  - architecture
  - complexity
  - platform-agnostic
categories:
  - Tech Blog
share: true
---

Small decisions we make every day when we write code, bring complexity to our projects.

### Cyclomatic complexity
Every additional `return` (or other exit) in a function increases its cyclomatic complexity (or number of independent paths through the function - we explained it in a previous article).

_More complex:_

```swift
func doSomething(x: Int) -> Int {
    let y = x + 10
    if y > 0 {
        return y
    } else {
        return 0
    }
}
```

_Less complex:_

```swift
func doSomething(x: Int) -> Int {
    let y = x + 10
    return y
}
```
Sometimes this complexity is **essential** (inherent to the problem), so we cannot do much with it. The 2 funtions in the previous example just do different things. 

But in other cases we can do some changes to minimise cyclomatic complexity.

_More complex:_

```swift
func handleNotification(_ type: String, isUserLoggedIn: Bool) {
    if type == "message" {                    
        if isUserLoggedIn {
            openMessages()
        } else {
            showLoginPrompt()
        }
    } else if type == "promo" {
        showPromotion()
    } else if type == "alert" {
        showAlert()
    }
}

```
(cyclomatic complexity = 5)

_Less complex:_

```swift
func handleNotification(_ type: String, isUserLoggedIn: Bool) {
    switch type {
    case "message":
        handleMessage(isUserLoggedIn)
    case "promo": 
        showPromotion()
    case "alert":
        showAlert()
    default:
        break
    }
}

func handleMessage(_ isUserLoggedIn: Bool) {
    isUserLoggedIn ? openMessages() : showLoginPrompt()
}

```
(cyclomatic complexity = 3 + 2)

Even though the overall complexity of this piece of logic remained the same we split it into 2 functions and made it more digestable. As in most cases you don't need to consume it all at once. Moreover we got a better separation of concerns; and 2 small functions are easier to test then one big one.

It's usually considered that when a function has more than two or three returns, it's usually a sign that the complexity is too high and refactoring is suggested. With complexity more than 10, a linter normally shows a red flag.

### Nesting level

Nesting level is something we can fully control as developers.
In the following example we have 3 levels of nested types: About This App Configuration, Entry, and Content.

```swift
public struct AboutThisAppConfiguration {
    
    public struct Entry {
        
        public enum Content {
            case modal(AboutLegalEntryCoordinator)
            case confirmedDeepLink(ConfirmationAlertPresenter)
        }
                
        public let title: String
        public let content: Content
        
        public init(title: String, icon: UIImage? = nil, content: Content,
                    trackingIdentifier: String, accessibilityIdentifier: String) {
            self.title = title
            self.content = content
        }
    }
        
    public let entries: [Entry]
        
    public init(entries: [Entry]) {
        self.entries = entries
    }
}
```
The cognitive load of such solution high as for each nested structure you need to keep the context of its parent (or even grandparent) in mind. You deal with the `Content`, but you will likely need to consider `Entry` and maybe even `AboutThisAppConfiguration` for the full context. The cognitive contexts of them overlap:

![](/images-posts/2025-04-14-complexity-1-decisions-in-code/context-overlap.png)

 So in this case it’s probably easier to split them into a separate data types, even if it looks more verbose in terms of naming.

```swift
public struct AboutThisAppConfiguration {
        
    public let entries: [AboutThisAppConfigurationEntry]
    public init(entries: [Entry]) {
        self.entries = entries
    }
}

public struct AboutThisAppConfigurationEntry {
            
    public let title: String
    public let content: AboutThisAppConfigurationEntryContent
    public init(title: String, icon: UIImage? = nil, content: Content,
                trackingIdentifier: String, accessibilityIdentifier: String) {
        self.title = title
        self.content = content
    }
}

public enum AboutThisAppConfigurationEntryContent {
    case modal(AboutLegalEntryCoordinator)
    case confirmedDeepLink(ConfirmationAlertPresenter)
}
```

This way the contexts don't overlap:

![](/images-posts/2025-04-14-complexity-1-decisions-in-code/context-overlap-fixed.png)

There might be some exception like using nested structs and enums as name spaces. 

```swift
public enum AccessibilityIdentifiers {
    
    // MARK: - AboutThisApp
    
    public enum About {
        public static var view = "view"
        public static var list = "list"
        public static var tour = "tour"
        
        public enum Legal {
            public static var view = "view"
            public static var terms = "legalTermsconditionsEntry"
            public static var copyrights = "legalCopyrightsEntry"
            
            public enum Copyrights {
                public static var view = "view"
                ...
            }
            ...
        }
        ...
    }
}
```

So it can be used like `AccessibilityIdentifiers.About.Legal.copyrights`.

Be careful with it, it only works when you don’t need to get inside this nested types, which is the case for constants like Accessibility Identifiers. If the types require instantiation or even some logic (like the previous example with `AboutThisAppConfiguration`), you will need to ocasionally take a look inside it. Hence no nesting is suggested in those cases.

### Number of parameters

Number of parameter is another source of redundant complexity in code. Too many parameters in a function usually indicate that it has multiple responsibilities and should be split.
If the function has one responsibility but still requires many parameters, consider grouping them into a separate data structure. 

_More complex:_

```swift
public func trackFormStep(formId: String,
                          formStep: String,
                          formStatus: String,
                          transactionId: String?,
                          formOutcome: String?,
                          formType: String?) {
    ...
}
```
_Less complex:_

```swift
public func trackFormStep(content: FormStepTrackingContent) {
    ...
}
    
public struct FormStepTrackingContent: Equatable, Sendable {
    public let formId: String
    public let formStep: String
    public let formStatus: String
    public let transactionId: String?
    public let formOutcome: String?
    public let formType: String?
    
    public init(formId: String,
                formStep: String,
                formStatus: String,
                transactionId: String?,
                formOutcome: String?,
                formType: String?) {
        ...
    }
} 
```

This reduces the number of entities you need to keep in mind when working with the function.

### Complex conditions

Complex conditions may be completely unreadable:

```swift
        if (featureToggles.toggle(for: .inAppReview) == .enabled &&
            (numberOfLaunchesSinceLastPrompted >= 
                  configuration.minimumRequiredLaunches) ||
            (dateProvider() >= nextPromptDate &&
           applicationVersion != latestVersionPromptedForReview)) {
            attemptToShowNativeRating(in: windowScene, completion: completion)
        }
```

A better approach: break them into logical steps, assign parts to descriptive boolean variables, use those variables to make the condition self-explanatory:


```swift
let featureIsActive = featureToggles.toggle(for: .inAppReview) == .enabled
let enoughLaunches = numberOfLaunchesSinceLastPrompted >= 
configuration.minimumRequiredLaunches
let dateVersionConditionMet = (dateProvider() >= nextPromptDate && 
applicationVersion != latestVersionPromptedForReview)


if featureIsActive && (enoughLaunches || dateVersionConditionMet) {
attemptToShowNativeRating(in: windowScene, completion: completion)
}
```

### Nested `if`

Nested `if`-conditions (_which are a specific case of increasing syclomatic complexity_) deserve a specific mention, as it's one of the most widely spread anti-pattern. Usually you can quite easily simplify it:

_More complex:_

```swift
if cardIds.count > 1 {
    cardDismissHandler()
} else {
    if insightsWidgetViewController != nil {
        cardDismissHandler()
    }
    insightsWidgetCoordinatorDelegate?.dismissWidget(at: insightsLocation)
}
```
_Less complex:_

```swift
if cardIds.count > 1 || insightsWidgetViewController != nil {
    cardDismissHandler()
} else {
    insightsWidgetCoordinatorDelegate?.dismissWidget(at: insightsLocation)
}
```

If your language supports early returns or constructs like guard, you can flatten the structure and improve readability:

_More complex:_

```swift
if let cardId {
    if let element = interaction.element(for: insightsLocation,
                                         cardId: cardId) else {
        return
    }
} else {
    tracker.trackElements(element,
                          page: analyticsPage(with: productName))
}
```
_Less complex:_

```swift
guard let cardId, let element = interaction.element(for: insightsLocation,
                                                    cardId: cardId) else { 
    return 
}

tracker.trackElements(element, page: analyticsPage(with: productName))
```

### Refactoring

There are more other anti-patterns like the ones mentioned above:

- Code duplication
- Divergent change
- Shotgun surgery
- Feature Envy
- Data Clumps
- ...

They are also known as **code smells**, and signal areas that should be refactored. Refactoring increases the readability, testability and maintainability of such code; makes it less error-prone.

A [classic book](https://www.goodreads.com/book/show/44936.Refactoring) on this topic was published 25 years ago, yet most of its techniques remain relevant today.

![](/images-posts/2025-04-14-complexity-1-decisions-in-code/refactoring.jpg)